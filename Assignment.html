<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Background Tasks API Project</title>
    <style>
        body {
            font-family: "Open Sans", "Lucida Grande", "Arial", sans-serif;
            font-size: 16px;
        }

        #logBox {
            margin-top: 16px;
            width: 400px;
            height: 500px;
            border-radius: 6px;
            border: 1px solid black;
            box-shadow: 4px 4px 2px black;
        }

        .logHeader {
            margin: 0;
            padding: 0 6px 4px;
            height: 22px;
            background-color: lightblue;
            border-bottom: 1px solid black;
            border-radius: 6px 6px 0 0;
        }

        #log {
            font:
                12px "Courier",
                monospace;
            padding: 6px;
            overflow: auto;
            overflow-y: scroll;
            width: 388px;
            height: 460px;
        }

      
        #container {
            border: 1px solid #ccc;
            padding: 15px;
            border-radius: 6px;
            background-color: #f9f9f9;
            width: 400px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 10px;
        }

        .label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        progress {
            width: 100%;
            height: 20px;
            margin-bottom: 10px;
            appearance: none;
            -webkit-appearance: none;
            border-radius: 3px;
        }

        progress::-webkit-progress-bar {
            background-color: #eee;
            border-radius: 3px;
        }

        progress::-webkit-progress-value {
            background-color: #4CAF50;
            border-radius: 3px;
        }

        .button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .button:hover {
            background-color: #0056b3;
        }

        .label.counter {
            margin-top: 10px;
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>
<body>
    <p>
        Demonstration of using cooperatively scheduled background tasks using the
        <code>requestIdleCallback()</code> method.
    </p>

    <div id="container">
        <div class="label">Decoding quantum filament tachyon emissionsâ€¦</div>

        <progress id="progress" value="0"></progress>

        <button class="button" id="startButton">Start</button>

        <div class="label counter">
            Task <span id="currentTaskNumber">0</span> of
            <span id="totalTaskCount">0</span>
        </div>
    </div>

    <div id="logBox">
        <div class="logHeader">Log</div>
        <div id="log"></div>
    </div>

    <script>
        const taskList = [];
        let totalTaskCount = 0;
        let currentTaskNumber = 0;
        let taskHandle = null;

        const totalTaskCountElem = document.getElementById("totalTaskCount");
        const currentTaskNumberElem = document.getElementById("currentTaskNumber");
        const progressBarElem = document.getElementById("progress");
        const startButtonElem = document.getElementById("startButton");
        const logElem = document.getElementById("log");

        let logFragment = null;
        let statusRefreshScheduled = false;

        
        window.requestIdleCallback ||= (handler) => {
            const startTime = Date.now();

            return setTimeout(() => {
                handler({
                    didTimeout: false,
                    timeRemaining() {
                        return Math.max(0, 50.0 - (Date.now() - startTime));
                    },
                });
            }, 1);
        };

        window.cancelIdleCallback ||= (id) => {
            clearTimeout(id);
        };

        function enqueueTask(taskHandler, taskData) {
            taskList.push({
                handler: taskHandler,
                data: taskData,
            });

            totalTaskCount++;

            taskHandle ||= requestIdleCallback(runTaskQueue, { timeout: 1000 });

            scheduleStatusRefresh();
        }

        function runTaskQueue(deadline) {
            while (
                (deadline.timeRemaining() > 0 || deadline.didTimeout) &&
                taskList.length
            ) {
                const task = taskList.shift();
                currentTaskNumber++;

                task.handler(task.data);
                scheduleStatusRefresh();
            }

            if (taskList.length) {
                taskHandle = requestIdleCallback(runTaskQueue, { timeout: 1000 });
            } else {
                taskHandle = 0; 
            }
        }

        function scheduleStatusRefresh() {
            if (!statusRefreshScheduled) {
                requestAnimationFrame(updateDisplay);
                statusRefreshScheduled = true;
            }
        }

        function updateDisplay() {
            const scrolledToEnd =
                logElem.scrollHeight - logElem.clientHeight <= logElem.scrollTop + 1;

            if (totalTaskCount) {
                if (progressBarElem.max !== totalTaskCount) {
                    totalTaskCountElem.textContent = totalTaskCount;
                    progressBarElem.max = totalTaskCount;
                }

                if (progressBarElem.value !== currentTaskNumber) {
                    currentTaskNumberElem.textContent = currentTaskNumber;
                    progressBarElem.value = currentTaskNumber;
                }
            }

            if (logFragment) {
                logElem.appendChild(logFragment);
                logFragment = null;
            }

            if (scrolledToEnd) {
                logElem.scrollTop = logElem.scrollHeight - logElem.clientHeight;
            }

            statusRefreshScheduled = false;
        }

        function log(text) {
            logFragment ??= document.createDocumentFragment();
            const el = document.createElement("div");
            el.textContent = text;
            logFragment.appendChild(el);
            
            scheduleStatusRefresh();
        }

        function logTaskHandler(data) {
            log(`Running task #${currentTaskNumber}`);

            for (let i = 0; i < data.count; i += 1) {
                log(`${(i + 1).toString()}. ${data.text}`);
            }
        }

        function getRandomIntInclusive(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function decodeTechnoStuff() {
            totalTaskCount = 0;
            currentTaskNumber = 0;
            updateDisplay(); 

            
            logElem.innerHTML = '';
            logFragment = null;

            const n = getRandomIntInclusive(100, 200);

            for (let i = 0; i < n; i++) {
                const taskData = {
                    count: getRandomIntInclusive(75, 150),
                    text: `This text is from task number ${i + 1} of ${n}`,
                };

                enqueueTask(logTaskHandler, taskData);
            }
        }

        document
            .getElementById("startButton")
            .addEventListener("click", decodeTechnoStuff, false);

        
        updateDisplay();
    </script>
</body>
</html>
